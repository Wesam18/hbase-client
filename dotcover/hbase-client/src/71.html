<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\projects\github\wesam18\hbase-client\src\hbase.stargate.client\models\extensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
#region FreeBSD

// Copyright (c) 2013, The Tribe
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// 
//  * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// 
//  * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#endregion

using System.Collections.Generic;
using System.Linq;

namespace HBase.Stargate.Client.Models
{
	/// &lt;summary&gt;
	///    Provides general extensions for Stargate Client components.
	/// &lt;/summary&gt;
	public static class Extensions
	{
		/// &lt;summary&gt;
		///    Converts the text to a nullable 32-bit integer value.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;text&quot;&gt;The text.&lt;/param&gt;
		public static int? ToNullableInt32(this string text)
		{
			if (string.IsNullOrWhiteSpace(text))
			{
				return null;
			}

			int value;
			return int.TryParse(text, out value) ? value : (int?) null;
		}

		/// &lt;summary&gt;
		///    Converts the text to a nullable 64-bit integer value.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;text&quot;&gt;The text.&lt;/param&gt;
		public static long? ToNullableInt64(this string text)
		{
			if (string.IsNullOrWhiteSpace(text))
			{
				return null;
			}

			long value;
			return long.TryParse(text, out value) ? value : (long?) null;
		}

		/// &lt;summary&gt;
		///    Determines whether the descriptor can describe a table.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;descriptor&quot;&gt;The descriptor.&lt;/param&gt;
		public static bool CanDescribeTable(this HBaseDescriptor descriptor)
		{
			return descriptor != null &amp;&amp; !string.IsNullOrEmpty(descriptor.Table);
		}

		/// &lt;summary&gt;
		///    Determines whether the descriptor can describe a row.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;descriptor&quot;&gt;The descriptor.&lt;/param&gt;
		public static bool CanDescribeRow(this HBaseDescriptor descriptor)
		{
			return descriptor.CanDescribeTable() &amp;&amp; !string.IsNullOrEmpty(descriptor.Row);
		}

		/// &lt;summary&gt;
		///    Determines whether the identifier can describe a cell.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;identifier&quot;&gt;The identifier.&lt;/param&gt;
		public static bool CanDescribeCell(this Identifier identifier)
		{
			return identifier.CanDescribeRow() &amp;&amp; identifier.CellDescriptor != null &amp;&amp; !string.IsNullOrEmpty(identifier.CellDescriptor.Column);
		}

		/// &lt;summary&gt;
		///    Converts the identifier into a cell query.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;identifier&quot;&gt;The identifier.&lt;/param&gt;
		public static CellQuery ToQuery(this Identifier identifier)
		{
			return new CellQuery
			{
				Table = identifier.Table,
				Row = identifier.Row,
				Cells = new[] {identifier.CellDescriptor},
				BeginTimestamp = identifier.Timestamp.HasValue ? identifier.Timestamp : null,
				EndTimestamp = identifier.Timestamp.HasValue ? identifier.Timestamp + 1 : null,
				MaxVersions = 1
			};
		}

		/// &lt;summary&gt;
		///    Returns a value indicating whether or not the two identifiers match.
		///    If a property has not been set on the other identifier, it will not be included
		///    in the evaluation.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;identifier&quot;&gt;The identifier.&lt;/param&gt;
		/// &lt;param name=&quot;other&quot;&gt;The other identifier.&lt;/param&gt;
		public static bool Matches(this Identifier identifier, Identifier other)
		{
			if (!string.IsNullOrEmpty(other.Table) &amp;&amp; other.Table != identifier.Table)
			{
				return false;
			}

			if (!string.IsNullOrEmpty(other.Row) &amp;&amp; other.Row != identifier.Row)
			{
				return false;
			}

			HBaseCellDescriptor otherCell = other.CellDescriptor;
			HBaseCellDescriptor currentCell = identifier.CellDescriptor;

			if (otherCell != null &amp;&amp; currentCell != null)
			{
				if (!string.IsNullOrEmpty(otherCell.Column) &amp;&amp; otherCell.Column != currentCell.Column)
				{
					return false;
				}

				if (!string.IsNullOrEmpty(otherCell.Qualifier) &amp;&amp; otherCell.Qualifier != currentCell.Qualifier)
				{
					return false;
				}
			}

			return !other.Timestamp.HasValue || other.Timestamp == identifier.Timestamp;
		}

		/// &lt;summary&gt;
		/// Gets the first value with an identifier matching the one specified.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;cellSet&quot;&gt;The cell set.&lt;/param&gt;
		/// &lt;param name=&quot;identifier&quot;&gt;The identifier.&lt;/param&gt;
		public static string GetValue(this IEnumerable&lt;Cell&gt; cellSet, Identifier identifier)
		{
			return cellSet.Where(cell =&gt; cell.Identifier.Matches(identifier))
				.Select(cell =&gt; cell.Value)
				.FirstOrDefault();
		}

		/// &lt;summary&gt;
		///    Gets the first value with the specified identifier values.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;cellSet&quot;&gt;The cell set.&lt;/param&gt;
		/// &lt;param name=&quot;table&quot;&gt;The table.&lt;/param&gt;
		/// &lt;param name=&quot;row&quot;&gt;The row.&lt;/param&gt;
		/// &lt;param name=&quot;column&quot;&gt;The column.&lt;/param&gt;
		/// &lt;param name=&quot;qualifier&quot;&gt;The qualifier.&lt;/param&gt;
		/// &lt;param name=&quot;timestamp&quot;&gt;The timestamp.&lt;/param&gt;
		public static string GetValue(this IEnumerable&lt;Cell&gt; cellSet, string table = null, string row = null, string column = null, string qualifier = null,
			long? timestamp = null)
		{
			return cellSet.GetValue(new Identifier
			{
				Table = table,
				Row = row,
				CellDescriptor = new HBaseCellDescriptor
				{
					Column = column,
					Qualifier = qualifier
				},
				Timestamp = timestamp
			});
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[37,3,37,4,1],[38,4,38,40,1],[39,4,39,5,1],[40,5,40,17,1],[44,4,44,63,1],[45,3,45,4,1],[52,3,52,4,1],[53,4,53,40,1],[54,4,54,5,1],[55,5,55,17,1],[59,4,59,65,1],[60,3,60,4,1],[67,3,67,4,1],[68,4,68,73,1],[69,3,69,4,1],[76,3,76,4,1],[77,4,77,82,1],[78,3,78,4,1],[85,3,85,4,1],[86,4,86,135,1],[87,3,87,4,1],[114,3,114,4,1],[115,4,115,78,1],[116,4,116,5,1],[117,5,117,18,1],[120,4,120,72,1],[121,4,121,5,1],[122,5,122,18,1],[125,4,125,57,1],[126,4,126,64,1],[128,4,128,49,1],[129,4,129,5,1],[130,5,130,91,1],[131,5,131,6,1],[132,6,132,19,1],[135,5,135,100,1],[136,5,136,6,1],[137,6,137,19,1],[139,4,139,5,1],[141,4,141,80,1],[142,3,142,4,1],[94,3,94,4,0],[95,4,103,6,0],[104,3,104,4,0],[150,3,150,4,0],[151,4,151,33,0],[152,31,153,23,0],[154,3,154,4,0],[167,3,167,4,0],[168,4,178,7,0],[179,3,179,4,0],[152,21,152,31,0],[151,33,151,68,0]]);
    </script>
  </body>
</html>